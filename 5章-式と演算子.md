# 5章　式と演算子

演算子(オペレータ)。 
被演算子(オペランド)。 
式について計算を実行することを「評価(evaluate)する」と言う。式は評価され、その結果として「値(value)」をもつ。 

```js
let x, y;
y = x = 3 * 5; // オリジナルの文
y = x =  15; // 掛け算が評価された
y = 15; // ひとつめの代入が評価され、xの値は15になる。yはまだundefined
15; // ふたつめの代入が評価され、yの値は15になる。
// 結果は15になるが、この値は使われていないので、破棄される。
```

## 5.1　演算子
たとえば「1 + 2」という式では、「1」や「2」が被演算子で「+」が演算子である。 

## 5.2　算術演算子
- +
- ハイフン
- /
- *
- %
- - : 負の値
- + : xが数値ではない場合は数値への変換を試みる。文字列を数値に変換したい場合などに用いる。(単項符号反転。減算よりも先に評価される)
    - xが5の場合は、-xは-5となる。
- ++/-- : 1を加える/引く。前につけば式は加えた/引いた後の値となる。後ろにつけば式は加える/引く前の値となる。

```js
const s = "5";
console.log(3 + +s); // 8   +sによってsは数値5に変換される。3 + 5 = 8
console.log(3 + s); // 35   sは文字列の5である。数値+文字列は、文字列の連結になる。35

const x1 = 0,  x2 = 3, x3 = -1,5, x4 = -6.33;
console.log(-x1*1); // -0   1*1=1の-で負数に変換？
console.log(+x2*2); // 

```
```js
let x = 2; 
console.log(x++ + x++);     // 2 + 3 = 5  xは4
console.log(++x + ++x);     // 5 + 6 = 11 xは6
console.log(x++ + ++x);     // 6 + 7 = 13 xは8
console.log(++x + x++);     // 9 + 9 = 18 xは10
console.log(x) 
console.log("-----") 
let y = 10; 
console.log(y-- + y--);     // 10 + 9 = 19 xは8
console.log(--y + --y);     // 7 + 6  = 13 xは6
console.log(y-- + --y);     // 6 + 4 = 10  xは4
console.log(--y + y--);     // 3 + 3 = 6   xは2
console.log(y)
```


## 5.3　演算子の優先順位
括弧で囲まれたものの優先順位が最も高い。乗算除算は足し算引き算よりも優先される。 
JavaScriptには58の演算子があり、20の「優先順位のレベル」にグループ化されている。


## 5.4　比較演算子
比較演算子は、厳密等価演算子、等価演算子、関係演算子の3種類である。厳密等価演算子は同値演算子と呼ばれることもある。　

### 5.4.1　厳密等価演算子と等価演算子
厳密等価であるかどうか調べるには、===(厳密等価演算子)あるいは!==(厳密不等価演算子)を用いる。 
2つの値が厳密等価であると見なされるのは次のいずれかの場合である。
- 同じオブジェクトを参照しているとき
- プリミティブ型で、データ型も値も同じであるとき

2つの値が等価であると見なされるのは次のいずれかの場合である。
- 同じオブジェクトを参照しているとき
- 「同じ値に変換される」とき

等価演算子では、文字列"33"と数値33を等価である。また0と""は等価となる。混乱を招く要因になるので、厳密等価演算子が強く推奨される。 
同じオブジェクトの参照は、厳密等価かつ等価である。 
```js
//オブジェクトは単体で独立している
const a = { name: "あるオブジェクト"};
const b = { name: "あるオブジェクト"};
a === b; // false
a == b;  // false
```

### 5.4.2　関係演算子
関係演算子は、<、<=、>、>=の四種類があり、二つの値を比較する。　

### 5.4.3　数値を比較する際の留意点
数値を比べる際の注意点 
NaNは、NaN自身を含め、**どの値とも**等しくはならない。
変数などが数値かどうか確認したい場合は、組み込みの関数isNaNを使う。isNunは、xが数値でない場合(xがNaNである場合を含む)はtrueを返し、それ以外はfalseを返す。 
```js
console.log(NaN === NaN); // false
console.log(isNaN(NaN)); // true
console.log(isNaN(3)); // false
```

JavaScriptでは、数値はすべて倍精度浮動小数点数である。
```js
// 0からx === 0.3まで、0.1ずつ足すというループだが、厳密にはxは0.3にはならないため、無限ループになる
let x = 0;
while(true) {
    x += 0.1;
    console.log(x);
    if(x === 0.3) break;
}

// Number.EPSILONは特殊な定数であり、比較を「ゆるく(2.22E-16分」する
let x = 0;
while(true) {
    x += 0.1;
    console.log(x);
    if(Math.abs(x - 0.3) < Number.EPISILON) break;
}
// 0.30000000000004で停止
```


## 5.5　文字列連結
JavaScriptでは、「+」は数値の足し算と文字列連結を兼ねている。
JavaScriptの処理系では、被演算子のデータ型から「+」が加算なのか文字列連結なのかを判断する。いずれも左から右へと評価される。
```js
console.log(3 + 5 + "8"); // 左から右へ 数値の足し算(3 + 5 = 8) 文字列連結(8 + "8" = 88)
console.log("3" + 5 + 8); // ("3" + 5)は文字列35として評価され、("35" + 8)は文字列連結として評価され、358が出力される。
```

## 5.6　論理演算子
通常、論理演算子が扱うのは論理値のみで、値はtrueとfalseのどちらかしか取らない。
JavaScriptでは、論理値ではない値に対しても演算を行うことができ、論理値以外の値を返すことさえできる。 


### 5.6.1　真と見なされる値と偽と見なされる値
JavaScriptでは、数値に限らずどのデータ型も論理演算の対象となる。この仕様により、すべての値を「真と見なされる値」または「偽と見なされる値」のどちらかに分けることができる。  
JavaScriptで偽と見なされるのは以下の6つのみであり、その他はすべて真と見なされる。 

- undefined
- null
- false
- 0
- NaN
- ''(空文字列)

以下は真と見なされるうちで注意が必要なものである。 

- 任意のオブジェクト(falseを返すオブジェクトも含む)
- 任意の配列(空の配列も含む)
- 空白のみを含む文字列(" "など)
- 文字列"false"

もし配列arrが空の場合に偽と見なすような処理をしたいときは、arr.lengthを使う。配列が空の場合は長さが0になるためfalseと判断される。 


### 5.6.2　AND、OR、NOT
JavaScriptでサポートされている論理演算子は論理積AND(&&)、論理和OR(||)、論理否定NOT(!)の3つである。 結果は論理値表にまとめられる。
ANDがtrueとなるのは、両方の被演算子がtrueの場合のみである。
ORがfalseとなるのは、両方の被演算子がfalseの場合のみである。
JavaScriptには、排他的論理和(XOR:どちらか2つのうち1つが真なら真、両方真のときは偽になる)に相当する論理演算子はない。ビット演算では、以下。


### 5.6.3　短絡評価
ANDとORは、両方の被演算子がtrue/falseの場合のみ、true/falseの値をとる。このため、片方だけを調べて処理を簡略化することができる。この簡略化は「短絡評価」と呼ばれている。 
短絡評価により副作用が生じるため、注意が必要である。 
```js
// ORは左辺がtrueなら右辺にどんな値がきてもtrueになると短絡評価できる。その結果、xのインクリメントは動作されず、xは0のままになる。
const skipIt = true;
let x = 0;
const result = skipIt || x++;
```

### 5.6.4　論理値ではない被演算子を用いた論理演算
被演算子が論理値でない場合は、「結果を決めた」値が返される。


## 5.7　条件演算子
条件演算子はJavaScriptで唯一の三項演算子で、if...else文に相当する式である。
```js
const doIt = false;
const result = doIt ? "Did it!" : "Didn't do it.";
console.log(result); // Didn't do it.
```


## 5.8　カンマ演算子
カンマ演算子「,」を使えば、複数の式を簡単に組み合わせることができる。「,」は、2つの式を評価して2つ目の結果を返す。 
for文の「初期化」や「再設定」で複数の式を実行するときなど、「複数の式を実行するが、必要な値は最後の式の結果だけ」という場合に便利である。
```js
// 二行目で、xとyはインクリメントされて、それぞれ0と10が代入される。
let x = 0, y = 10, z;
z = (x++, y++);
console.log(z); // 10

// 二行目で、まずx++が行われてzに代入される。次にy++がそれとは別に行われる。両方ともインクリメントされるが、代入されるのはxのみである。
let 0, y= 10;
z = x++, y++;
console.log(z); // 0
```


## 5.9　グループ化演算子
演算子の優先順位を変えたり明確化するのに使う丸括弧の組(...)を、グループ化演算子と呼ぶ。


## 5.10　ビット演算子
ビット演算子を使うと、数値のそれぞれのビットに対して操作を行うことができる。 
JavaScriptの数値はすべて倍精度なので、ビット演算を実行する前に処理系が数値を32ビットの整数に変換し、結果を返す前に倍精度に変換している。 

## 5.11　typeof演算子
typeof演算子は、被演算子のデータ型を表す文字列を返す。しかし、データ型に正確に対応していないため、使用しないほうがよい。(nullにはプリミティブではなくobjectを返す、配列オブジェクトと非配列オブジェクトを区別することができない) 
批判にさらされているが、多くの既存のコードがこの動作に依存しているため、いまだに言語使用に残っている。 


## 5.12　void演算子
void演算子は、被演算子を評価してundefinedを返す。使用する機会はほとんどない。 


## 5.13　代入演算子
代入演算子は値を変数に代入する。等号の左辺は、値を保存できるものである必要がある。 
定数への値の代入は、厳密には宣言(の一部)であり、代入演算子ではない。 
代入はそれ自体が式であり、返される値は代入される値である。 

```js
let v, v0;
v = v0 = 9.8; 
console.log(v); // 9.8
console.log(v0); // 9.8
```
```js
const nums = [ 3, 5, 15, 7, 5 ];
let n, i=0;
while(i<nums.length && (n = nums[i++]) < 10) {
    console.log(`10より小さい数字を発見：${n}`);
}
    console.log(`10より大きい数字を発見：${n}`);
    console.log(`未チェックの数字の個数：${nums.length-i}`);
```


## 5.14　分割代入（デストラクチャリング）
分割代入(デストラクチャリング)は、オブジェクトや配列を複数の変数に簡単に「分割」できる。ES2015から導入された。

```js
// オブジェクトの分割
const obj = { b: 2, c: 3, d: 4 }; // オブジェクトの定義
const {a, b, c} = obj; // 分割代入、宣言と同時に代入する
({a, b, c} = obj); // 宣言とは別に代入する場合は、()で囲まなければならない
console.log(a); // undefined
console.log(b); // 2
console.log(c); // 3
console.log(d); // ReferenceError: d is notdeined (エラー。dには代入されていない)
```
```js
// 配列の分割
// 配列の分割では、配列の要素に対応して順番に代入できる。変数レストを使うことで、残りの要素をすべて捕捉し代入することができる
const arr = [1, 2, 3, 4, 5];
let [x, y, ...rest] = arr;
console.log(x); // 1
console.log(y); // 2
console.log(rest); // [ 3, 4, 5 ]
```

## 5.15　オブジェクト演算子と配列演算子
オブジェクト、配列および関数に関して特別な演算子が用意されている。 

- .         : プロパティ(メンバー)へのアクセス
- []        : 計算値によるメンバーアクセス。有効な識別子ではないプロパティ名を使いたいとき
- in        : プロパティの有無を調べる
- new       : オブジェクトのインスタンス生成
- instanceof: プロトタイプチェインをテスト
- ...       : 展開
- delete    : 削除


## 5.16　テンプレートリテラル内の式
テンプレートリテラルを使えば、任意の式の値を文字列に含めることができる。 
```js
const roomTempC = 26.5;
let currentTempC = 34.5;
console.log(`室温と気温の差：${currentTempC - roomTempC}度`);
console.log(`現在の温度(華氏)：${currentTempC * 9/5 + 32}℉`);
```

## 5.17　式と制御フローのパターン
制御フローに影響する可能性のある式(三項演算子を使った式や短絡評価など)に関連する制御フローのパターン 


### 5.17.1　if...else文を条件演算子を使った構文に変換
if...else文は、条件演算子によってコンパクトに書ける 
```js
// if else文

if(isPrime(n)) {    // 素数か？
    label = '素数';
} else {
    label = '非素数';
}

// 条件演算子
// 変数labelに格納されたnをisPrimeした値がtrueであれば素数、falseであれば非素数
label = isPrime(n) ? '素数' : '非素数';
```


### 5.17.2　if文の短絡論理ORへの変換
```js
// optionsの値がfalsyなら、optionsは空のオブジェクトを値とする
if(!options) options = {};

// 短絡論理ORであれば、optionsがfalsyであれば、結果が決定される。結果を決定する値{}が、otpionsに代入される
options = options || {};
```

## 5.18　まとめ
ビット演算子は滅多に使わないが、メンバーアクセス演算子などは意識せずに使うようになる。 
代入演算子、算術演算し、比較演算子、論理演算子はもっとも一般的な演算子であり、頻繁に登場するため、理解しておく。 