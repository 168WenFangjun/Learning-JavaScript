# 7章　スコープ
スコープは変数、定数および引数が有効な範囲を決める。 
スコープによって、いつ、どこで定義されていると見なされるか、どこで値を参照したり変えたりできるのかが決まる。 
関数の仮引数は関数が呼び出されるまでは存在しない。関数は呼ばれるたびにその引数の実体が生成され、呼び出された関数から制御が戻るときにスコープから消える。 
変数や定数は生成されるまで存在しない。letあるいはconstで宣言されるまでは、スコープにはない。 


## 7.1　スコープと存在
変数が存在しなければ、スコープ内にないのは自明である。 
しかし、変数がスコープ内にないからといって、存在していないわけではない。 
- スコープ： 現在実行中の実行テキストで見えていてアクセスできる識別子の集合
- 存在    ：メモリが確保されて何かを保持している識別子であるかどうか
JavaScriptはガベージコレクションによって管理を行う必要のない変数などのメモリを回収している。

## 7.2　静的スコープと動的スコープ
JavaScriptのスコープは静的スコープである。
静的スコープにおいては、関数は、それが定義されたときにスコープにある識別子にのみアクセスできる。関数が呼び出されたところでスコープにある識別子ではない。
```js
// 関数fが定義されたとき、既に変数xは存在しているが、変数yは存在していない。
// [？] f()を最後にするとconsole.log(y)は動作する。なぜか。
'use strict';
const x = 3;
function f() {
  console.log(x); // 3
  console.log(y); // ReferenceError: y is not defined
}
f();
const y = 3;
```


## 7.3　グローバルスコープ
グローバルスコープは、スコープの階層構造の根本に存在する。 
JavaScriptのプログラムが、実行開始し関数を呼び出す前には、は必ずグローバルスコープで実行される。つまり、グローバルスコープで宣言したものはすべてのプゴラムのすべてのスコープで利用可能になる。 
すべてで利用可能であるため、どこでも変更できてしまう危険性がある。 

大規模なプログラムを作る場合は、そのすべてを把握することはできない。グローバルスコープに依存すると、なにを指定しているのか厳密ではなく、また、いつでも変更可能であるため他から影響を受けてしまう危険性もある。したがって、グローバル変数に依存しないようにすることが大切である。 


```js
// プログラム中のどこで定義された関数でもnameの値を変更できてしまう。

let name = "桃太郎"; /* グローバル変数 */
let age = 25; /* グローバル変数 */

function greet() {
console.log(`こんにちは、${name}さん! `); 
}

function getBirthYear() {
return new Date().getFullYear() - age;
}
greet(); // こんにちは、桃太郎さん!
console.log(getBirthYear()); // 1991
```
ユーザーの情報をオブジェクトにまとめることで、情報を限定的にできる。どこでも変更できてしまう情報ではなくなる。 
しかし、依然としてグローバル変数userに依存している状態である。 
```js
let user = { /* オブジェクトを定義 */
  name: "桃太郎",
  age: 25,
};

function greet() { /* あいさつをする */
console.log(`こんにちは、${user.name}さん! `); 
}
function getBirthYear() { /* 生年を得る */
return new Date().getFullYear() - user.age; 
}
greet(); // こんにちは、桃太郎さん!
console.log(getBirthYear()); // 1991
```
関数に仮引数personを指定することで、2つの関数を任意のスコープから、明示的にユーザーを指定して呼び出すことができる。 
仮引数personにオブジェクトを渡すことで、呼び出し時に指定することができ、グローバルオブジェクトに依存しないで済む。 
```js
let user = { /* オブジェクトを定義 */ 
  name: "桃太郎",
  age: 25,
};

let user2 = {
  name: "黄猿",
  age: 25,
};

function greet(person) { /* あいさつをする */
console.log(`こんにちは、${person.name}さん! `);
 }
function getBirthYear(person) { /* 生年を得る */
return new Date().getFullYear() - person.age;
 }
greet(user2); // こんにちは、桃太郎さん!
console.log(getBirthYear(user2)); // 1991
```

## 7.4　ブロックスコープ
letとconstは識別子を「ブロックスコープ」で定義する。 
ブロックスコープで定義された識別子はそれを囲むブロックでしか有効にはならない。 


## 7.5　変数の隠蔽
**同じ名前の変数や定数**が異なるスコープで利用された場合も注意が必要である。 

```js
// スコープに交わりがない場合は、xの値はスコープ内で有効であり、スコープ外ではundefinedとなる
{
  const x = '青';
  console.log(x); // '青'
}
  console.log(typeof x); // undefined
{
  const x = 3;
  console.log(x); // 3
}
  console.log(typeof x); // undefined
```
```js
// スコープが入れ子になった場合は、内側の変数は外側の変数をマスクする。
// 実行が内側のブロックに入ったときは、外のxと内のxの2つの変数xが定義され、2つの変数がどちらもスコープに入っている
// 2つの変数は同じ名前だるために、内側のブロックで外側の変数にアクセスすることはできなくなっている
{
  let x = '青';
  console.log(x); // 青
  {
    let x = 3;
    console.log(x); // 3
  }
  console.log(x); // 青
}
```
```js
{
  let x = { color: "青"};
  let y = x;
  let z = 3;
  { 
    let x = 5;
    console.log(x); // 5 (外側のxとは異なる新しいxであり、外側をマスクする)
    console.log(y.color); //青 (yによって参照されているオブジェクトは、スコープに入っている。外側のブロックのxもスコープに入っている)
    y.color = "赤"
    console.log(z); // 3
  }
  console.log(x.color); // 赤
  console.log(y.color); // 赤
  console.log(z); // 3  
}
```

## 7.6　関数、クロージャ、静的スコープ
モダンなJavaScriptの開発においては、関数は必要なときにその場で定義される傾向にある。
クロージャは、特殊なスコープで定義された関数である。クロージャは、変数の周囲にスコープを閉じ込むものである。
クロージャを形成した関数は、ブロックスコープの外から内側に干渉することができる。(オブジェクトのプロパティを変更する、あるいは、クロージャ内の識別子を利用して実行ができる) 

```js
// 関数globalFuncを囲うブロックが、クロージャを形成している。
// 形成されたクロージャ内の変数であれば、関数globalFuncはどこから呼び出しても識別子にアクセスすることができる

let globalFunc;  // 未定義のグローバルな変数
  {
  let blockVar = 'a'; // ブロックスコープの変数
  globalFunc = function() {
    console.log(brlockVar)
  }
}
globalFunc(); // a
```
通常、スコープの外にはアクセスできない。しかし、関数を使うと例外的に「のぞき窓」を作ることができる。 
```js
let f; // 未定義のグローバルな変数
{
  let o = { note: '安全', note2: '大丈夫' };
  f = function() {
    console.log("無名関数の中：" + o.note); // 無名関数の中： 安全
    return o;
  }
}
let oRef = f();
console.log(oRef); // { note: '安全', note2: '大丈夫' };
oRef.note = "まったく安全ではない！";
console.log(oRef); // {note: 'まったく安全ではない！', note2: '大丈夫' }
```

## 7.7　IIFE.即座に実行される関数式
IIFE(immediately invoked function expression)、即時関数。宣言するとすぐに実行される。 
IIFEはブロックスコープの変数が導入されたため必要性が少し低下したが、まだ使い道はたくさんある。 
```js
(function() {
  // IIFEの本体
})();
```

```js
// 無名関数Bは、無名関数Aの戻り値として送られる
// Bの関数内ではcountは定義されていないが、Aによるクロージャでアクセスできる
const f = (function() {
  let count = 0;
  return function() {
    return `この関数が呼ばれた回数：${++count}回。`;
  }
})();

console.log(f()); // この関数が呼ばれた回数：1回。
console.log(f()); // この関数が呼ばれた回数：2回。
console.log(f()); // この関数が呼ばれた回数：3回。
```


## 7.8　関数のスコープと巻き上げ
varによって宣言された変数は「関数スコープ」をもつ。 
また「varを使って宣言されたグローバル変数」と「関数内でvarで宣言されずに使われた変数」は同じ振る舞いをする。(巻き上げ) 
- varや巻き上げについて理解する意味 
  - varが使われた大量のコードが残っている
  - 関数の宣言も巻き上げられる 

- let
  - 宣言するまでは存在しない
- var
  - 宣言の前でも有効になる(エラーにはならない)
JavaScriptの処理系はスコープ全体を見回してvarで宣言された同じ名前の変数があれば、それが使われている箇所で宣言さたものとして扱う。 
ただし、巻き上げは宣言だけで、値の代入までは巻き上げされない。 
```js
console.log(x); // undefined (巻き上げによりアクセスできるが、値はundefinedである)
x = 3;
console.log(x); // 3
```

## 7.9　関数の巻き上げ
関数宣言もスコープの先頭に巻き上げられる。したがって、関数宣言の前に呼び出すことができる。
```js
f(); // 関数fが呼び出された
function f() {
  console.log('関数fが呼び出された');
}
```

## 7.10　TDZ（TemporalDeadZone）
ES2015以前はtypeofを使って変数が定義されているか調べていた。letはそもそも宣言されるまで存在しないので調べる必要はない。
```js
// varに対してはtypeofを使って存在の有無を調べていた
if(typeof x === "undefined") {
  console.log("x は存在していない、あるいは undefined");
  } else {
    // xを参照しても大丈夫... 
  }
var x;
```

## 7.11　strictモード
ES5までの「暗黙的グローバル(varによる変数宣言の抜け落ち)」は、見つかりにくいエラーの原因は、strictモードの導入により対処された。 
全ファイルのスクリプトに適用されるグローバルスコープのstrictモード宣言は、必ずしも推奨されない。 
```js
// コーディングにstrictモードを適用したいなら、即時関数にまとめる方法がある。　
(function() {
  'use strict';

})();
```

## 7.12　まとめ
JavaScriptのマスターにスコープの理解は欠かせない。 
モダンなJavaScript開発にとってクロージャは欠かせない存在である。 
